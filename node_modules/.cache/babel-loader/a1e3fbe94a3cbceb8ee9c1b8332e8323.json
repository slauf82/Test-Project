{"ast":null,"code":"'use strict';\n\nvar _extends = Object.assign || function (target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i];\n\n    for (var key in source) {\n      if (Object.prototype.hasOwnProperty.call(source, key)) {\n        target[key] = source[key];\n      }\n    }\n  }\n\n  return target;\n};\n\nvar React = require('react');\n\nvar ReactDOM = require('react-dom');\n\nvar isFunction = require('lodash/isFunction');\n\nvar Draggable = require('react-draggable');\n\nvar isUndefined = require('lodash/isUndefined');\n\nvar throttle = require('lodash/throttle');\n\nmodule.exports = React.createClass({\n  displayName: 'core-slider',\n  propTypes: {\n    value: React.PropTypes.number,\n    min: React.PropTypes.number,\n    max: React.PropTypes.number,\n    ticks: React.PropTypes.bool,\n    triggerOnChangeWhileDragging: React.PropTypes.bool,\n    onChange: React.PropTypes.func,\n    onDragStart: React.PropTypes.func,\n    onDragEnd: React.PropTypes.func,\n    markerLabel: React.PropTypes.array\n  },\n  getDefaultProps: function getDefaultProps() {\n    return {\n      value: 0,\n      min: 0,\n      max: 10,\n      ticks: false,\n      triggerOnChangeWhileDragging: true\n    };\n  },\n  getInitialState: function getInitialState() {\n    return {\n      position: undefined,\n      value: this.props.value,\n      dragging: false\n    };\n  },\n  componentWillReceiveProps: function componentWillReceiveProps(nextProps, nextState) {\n    var newValue; // keep state up to date with passed in props\n\n    if (this.state.value !== nextProps.value) {\n      newValue = this.getBoundValue(nextProps, nextProps.value);\n      this.setState({\n        value: newValue\n      });\n      this.setHandlePosition(nextProps, newValue);\n    } // if min or max changes, have to reposition the handle\n\n\n    if (this.props.min !== nextProps.min || this.props.max !== nextProps.max) {\n      newValue = this.getBoundValue(nextProps, newValue || this.state.value);\n      this.setState({\n        value: newValue\n      });\n      this.setHandlePosition(nextProps, newValue);\n    }\n  },\n  shouldComponentUpdate: function shouldComponentUpdate(nextProps, nextState) {\n    // Don't alter the component while dragging is occurring\n    return !nextState.dragging;\n  },\n  componentDidMount: function componentDidMount() {\n    this.updateTrackWidth();\n    this.updateTrackWidth = throttle(this.updateTrackWidth, 100, {\n      leading: false\n    });\n    window.addEventListener('resize', this.updateTrackWidth);\n  },\n  componentWillUnmount: function componentWillUnmount() {\n    window.removeEventListener('resize', this.updateTrackWidth);\n  },\n  getBoundValue: function getBoundValue(props, value) {\n    var newValue = value;\n\n    if (newValue < props.min) {\n      newValue = props.min;\n    } else if (newValue > props.max) {\n      newValue = props.max;\n    }\n\n    return newValue;\n  },\n  updateTrackWidth: function updateTrackWidth() {\n    var track = ReactDOM.findDOMNode(this.refs.track);\n\n    if (!track) {\n      return;\n    }\n\n    var trackWidth = track.offsetWidth;\n    this.setState({\n      trackWidth: trackWidth\n    }, this.setHandlePosition);\n  },\n  componentDidUpdate: function componentDidUpdate() {\n    // after a render, ensure that draggable is in correct position\n    this.refs.drag && this.refs.drag.setState({\n      clientX: this.state.position\n    });\n  },\n  setHandlePosition: function setHandlePosition() {\n    var props = arguments.length <= 0 || arguments[0] === undefined ? this.props : arguments[0];\n    var value = arguments.length <= 1 || arguments[1] === undefined ? this.state.value : arguments[1];\n    var position = this.state.trackWidth / (props.max - props.min) * (value - props.min);\n    this.setState({\n      position: position\n    });\n  },\n  updateValueFromPosition: function updateValueFromPosition(newPosition) {\n    var currentPosition = newPosition;\n    var value, position;\n\n    if (this.props.max === this.props.min) {\n      value = this.props.min;\n      position = this.state.trackWidth / 2;\n    } else {\n      // find the two closest ticks to the current position\n      var currentPercent = currentPosition / this.state.trackWidth * 100;\n      var percentStep = 100 / (this.props.max - this.props.min);\n      var closestSmallerValue = Math.floor(currentPercent / percentStep);\n      var closestLargerValue = closestSmallerValue + 1;\n      var bestMatchPercent, bestMatchTick; // determine which of the two values is closest\n\n      if (currentPercent - closestSmallerValue * percentStep <= closestLargerValue * percentStep - currentPercent) {\n        bestMatchTick = closestSmallerValue;\n        bestMatchPercent = bestMatchTick * percentStep;\n      } else {\n        bestMatchTick = closestLargerValue;\n        bestMatchPercent = bestMatchTick * percentStep;\n      } // update the value and position\n\n\n      value = this.props.min + bestMatchTick;\n      position = this.state.trackWidth * (bestMatchPercent / 100);\n    } // Although set state is async, pushing its invocation as late as possible\n\n\n    this.setState({\n      value: value,\n      position: position\n    });\n    return {\n      value: value,\n      position: position\n    };\n  },\n  cumulativeOffset: function cumulativeOffset(element) {\n    // determine the overall offset of the element by crawling up the DOM, borrowed from Prototype.js\n    var top = 0;\n    var left = 0;\n\n    do {\n      top += element.offsetTop || 0;\n      left += element.offsetLeft || 0;\n      element = element.offsetParent;\n    } while (element);\n\n    return {\n      top: top,\n      left: left\n    };\n  },\n  triggerOnChange: function triggerOnChange(pos) {\n    var _updateValueFromPosit = this.updateValueFromPosition(pos);\n\n    var value = _updateValueFromPosit.value;\n    var position = _updateValueFromPosit.position;\n\n    if (isFunction(this.props.onChange)) {\n      this.props.onChange(value, position);\n    }\n  },\n  clickOnTrack: function clickOnTrack(event) {\n    var clickFromLeft = event.clientX - this.cumulativeOffset(event.target).left;\n    this.triggerOnChange(clickFromLeft);\n  },\n  handleUp: function handleUp(event, ui) {\n    var pos = this.refs.drag.state.clientX || 0;\n\n    var _updateValueFromPosit2 = this.updateValueFromPosition(pos);\n\n    var position = _updateValueFromPosit2.position; // Do we have a drag end hook ?\n\n    if (isFunction(this.props.onDragEnd)) {\n      this.props.onDragEnd(position);\n    }\n\n    this.setState({\n      dragging: false\n    });\n    this.triggerOnChange(position);\n  },\n  handleDown: function handleDown(event, ui) {\n    // Do we have a drag start hook ?\n    if (isFunction(this.props.onDragStart)) {\n      this.props.onDragStart(this.state.position);\n    }\n\n    this.setState({\n      dragging: true\n    });\n  },\n  dragging: function dragging(event, ui) {\n    var pos = this.refs.drag.state.clientX || 0; // Do we want to trigger change handlers while dragging ?\n\n    if (this.props.triggerOnChangeWhileDragging) {\n      this.triggerOnChange(pos);\n    }\n\n    event.preventDefault();\n  },\n  renderTicks: function renderTicks() {\n    if (!this.props.ticks) return React.createElement('span', null);\n    var elements = [];\n    var min = this.props.min;\n    var max = this.props.max;\n    var percentStep = 100 / (max - min); // Don't render ticks if it is too high. Will crash the browser and the ticks become useless\n\n    if (max - min < 200) {\n      for (var i = min + 1; i < max; i++) {\n        var style = {\n          left: percentStep * (i - min) + '%'\n        };\n        elements.push(React.createElement('span', {\n          key: 'tick' + i,\n          className: 'slider__tick',\n          style: style\n        }));\n      }\n    }\n\n    return React.createElement('div', {\n      key: 'ticks',\n      className: 'slider__ticks',\n      onClick: this.clickOnTrack\n    }, elements);\n  },\n  renderMarkers: function renderMarkers() {\n    if (!this.props.markerLabel) return React.createElement('span', null);\n    var elements = [];\n    var _props = this.props;\n    var min = _props.min;\n    var max = _props.max;\n    var markers = _props.markerLabel;\n    var percentStep = 100 / (max - min);\n\n    for (var i in markers) {\n      var style = {\n        left: percentStep * (markers[i].value - min) + '%'\n      };\n\n      if (markers[i].value <= max && markers[i].value >= min) {\n        if (this.props.ticks && max - min < 200) {\n          // don't render a tick for this marker if ticks are already being rendered\n          elements.push(React.createElement('div', {\n            key: 'marker' + i,\n            className: 'slider__marker marker',\n            style: style\n          }, React.createElement('p', {\n            className: 'marker__label'\n          }, markers[i].label)));\n        } else {\n          elements.push(React.createElement('div', {\n            key: 'marker' + i,\n            className: 'slider__marker marker',\n            style: style\n          }, React.createElement('p', {\n            className: 'marker__label'\n          }, markers[i].label), React.createElement('span', {\n            key: 'marker' + markers[i].value,\n            className: 'slider__tick slider__tick--marker'\n          })));\n        }\n      }\n    }\n\n    return React.createElement('div', {\n      key: 'markers',\n      className: 'slider__markers',\n      onClick: this.clickOnTrack\n    }, elements);\n  },\n  render: function render() {\n    var draggableProps, draggable;\n\n    if (!isUndefined(this.state.position)) {\n      draggableProps = {\n        axis: 'x',\n        handle: '.slider__handle',\n        bounds: {\n          left: 0,\n          right: this.state.trackWidth\n        },\n        start: {\n          x: this.state.position,\n          y: 0\n        },\n        onStop: this.handleUp,\n        onStart: this.handleDown,\n        onDrag: this.dragging\n      };\n      draggable = React.createElement(Draggable, _extends({\n        ref: 'drag',\n        key: 'draggable'\n      }, draggableProps), React.createElement('span', {\n        ref: 'handle',\n        className: 'slider__handle'\n      }));\n    }\n\n    return React.createElement('div', {\n      ref: 'slider',\n      className: 'slider'\n    }, draggable, React.createElement('div', {\n      ref: 'track',\n      className: 'slider__track',\n      onClick: this.clickOnTrack\n    }, this.renderTicks(), this.renderMarkers()));\n  }\n});","map":null,"metadata":{},"sourceType":"script"}