{"ast":null,"code":"(function webpackUniversalModuleDefinition(root, factory) {\n  if (typeof exports === 'object' && typeof module === 'object') module.exports = factory(require(\"react\"), require(\"react-dom\"));else if (typeof define === 'function' && define.amd) define([\"react\", \"react-dom\"], factory);else if (typeof exports === 'object') exports[\"ReactDraggable\"] = factory(require(\"react\"), require(\"react-dom\"));else root[\"ReactDraggable\"] = factory(root[\"React\"], root[\"ReactDOM\"]);\n})(this, function (__WEBPACK_EXTERNAL_MODULE_2__, __WEBPACK_EXTERNAL_MODULE_3__) {\n  return (\n    /******/\n    function (modules) {\n      // webpackBootstrap\n\n      /******/\n      // The module cache\n\n      /******/\n      var installedModules = {};\n      /******/\n\n      /******/\n      // The require function\n\n      /******/\n\n      function __webpack_require__(moduleId) {\n        /******/\n\n        /******/\n        // Check if module is in cache\n\n        /******/\n        if (installedModules[moduleId])\n          /******/\n          return installedModules[moduleId].exports;\n        /******/\n\n        /******/\n        // Create a new module (and put it into the cache)\n\n        /******/\n\n        var module = installedModules[moduleId] = {\n          /******/\n          exports: {},\n\n          /******/\n          id: moduleId,\n\n          /******/\n          loaded: false\n          /******/\n\n        };\n        /******/\n\n        /******/\n        // Execute the module function\n\n        /******/\n\n        modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n        /******/\n\n        /******/\n        // Flag the module as loaded\n\n        /******/\n\n        module.loaded = true;\n        /******/\n\n        /******/\n        // Return the exports of the module\n\n        /******/\n\n        return module.exports;\n        /******/\n      }\n      /******/\n\n      /******/\n\n      /******/\n      // expose the modules object (__webpack_modules__)\n\n      /******/\n\n\n      __webpack_require__.m = modules;\n      /******/\n\n      /******/\n      // expose the module cache\n\n      /******/\n\n      __webpack_require__.c = installedModules;\n      /******/\n\n      /******/\n      // __webpack_public_path__\n\n      /******/\n\n      __webpack_require__.p = \"\";\n      /******/\n\n      /******/\n      // Load entry module and return exports\n\n      /******/\n\n      return __webpack_require__(0);\n      /******/\n    }\n    /************************************************************************/\n\n    /******/\n    ([\n    /* 0 */\n\n    /***/\n    function (module, exports, __webpack_require__) {\n      'use strict';\n\n      module.exports = __webpack_require__(1).default;\n      module.exports.DraggableCore = __webpack_require__(9).default;\n      /***/\n    },\n    /* 1 */\n\n    /***/\n    function (module, exports, __webpack_require__) {\n      'use strict';\n\n      Object.defineProperty(exports, \"__esModule\", {\n        value: true\n      });\n\n      var _extends = Object.assign || function (target) {\n        for (var i = 1; i < arguments.length; i++) {\n          var source = arguments[i];\n\n          for (var key in source) {\n            if (Object.prototype.hasOwnProperty.call(source, key)) {\n              target[key] = source[key];\n            }\n          }\n        }\n\n        return target;\n      };\n\n      var _slicedToArray = function () {\n        function sliceIterator(arr, i) {\n          var _arr = [];\n          var _n = true;\n          var _d = false;\n          var _e = undefined;\n\n          try {\n            for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {\n              _arr.push(_s.value);\n\n              if (i && _arr.length === i) break;\n            }\n          } catch (err) {\n            _d = true;\n            _e = err;\n          } finally {\n            try {\n              if (!_n && _i[\"return\"]) _i[\"return\"]();\n            } finally {\n              if (_d) throw _e;\n            }\n          }\n\n          return _arr;\n        }\n\n        return function (arr, i) {\n          if (Array.isArray(arr)) {\n            return arr;\n          } else if (Symbol.iterator in Object(arr)) {\n            return sliceIterator(arr, i);\n          } else {\n            throw new TypeError(\"Invalid attempt to destructure non-iterable instance\");\n          }\n        };\n      }();\n\n      var _createClass = function () {\n        function defineProperties(target, props) {\n          for (var i = 0; i < props.length; i++) {\n            var descriptor = props[i];\n            descriptor.enumerable = descriptor.enumerable || false;\n            descriptor.configurable = true;\n            if (\"value\" in descriptor) descriptor.writable = true;\n            Object.defineProperty(target, descriptor.key, descriptor);\n          }\n        }\n\n        return function (Constructor, protoProps, staticProps) {\n          if (protoProps) defineProperties(Constructor.prototype, protoProps);\n          if (staticProps) defineProperties(Constructor, staticProps);\n          return Constructor;\n        };\n      }();\n\n      var _react = __webpack_require__(2);\n\n      var _react2 = _interopRequireDefault(_react);\n\n      var _reactDom = __webpack_require__(3);\n\n      var _reactDom2 = _interopRequireDefault(_reactDom);\n\n      var _classnames = __webpack_require__(4);\n\n      var _classnames2 = _interopRequireDefault(_classnames);\n\n      var _domFns = __webpack_require__(5);\n\n      var _positionFns = __webpack_require__(8);\n\n      var _shims = __webpack_require__(6);\n\n      var _DraggableCore = __webpack_require__(9);\n\n      var _DraggableCore2 = _interopRequireDefault(_DraggableCore);\n\n      var _log = __webpack_require__(10);\n\n      var _log2 = _interopRequireDefault(_log);\n\n      function _interopRequireDefault(obj) {\n        return obj && obj.__esModule ? obj : {\n          default: obj\n        };\n      }\n\n      function _classCallCheck(instance, Constructor) {\n        if (!(instance instanceof Constructor)) {\n          throw new TypeError(\"Cannot call a class as a function\");\n        }\n      }\n\n      function _possibleConstructorReturn(self, call) {\n        if (!self) {\n          throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n        }\n\n        return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self;\n      }\n\n      function _inherits(subClass, superClass) {\n        if (typeof superClass !== \"function\" && superClass !== null) {\n          throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass);\n        }\n\n        subClass.prototype = Object.create(superClass && superClass.prototype, {\n          constructor: {\n            value: subClass,\n            enumerable: false,\n            writable: true,\n            configurable: true\n          }\n        });\n        if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;\n      } // $FlowIgnore\n      //\n      // Define <Draggable>\n      //\n\n\n      var Draggable = function (_React$Component) {\n        _inherits(Draggable, _React$Component);\n\n        function Draggable() {\n          var _Object$getPrototypeO;\n\n          var _temp, _this, _ret;\n\n          _classCallCheck(this, Draggable);\n\n          for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {\n            args[_key] = arguments[_key];\n          }\n\n          return _ret = (_temp = (_this = _possibleConstructorReturn(this, (_Object$getPrototypeO = Object.getPrototypeOf(Draggable)).call.apply(_Object$getPrototypeO, [this].concat(args))), _this), _this.state = {\n            // Whether or not we are currently dragging.\n            dragging: false,\n            // Whether or not we have been dragged before.\n            dragged: false,\n            // Current transform x and y.\n            clientX: _this.props.start.x,\n            clientY: _this.props.start.y,\n            // Used for compensating for out-of-bounds drags\n            slackX: 0,\n            slackY: 0,\n            // Can only determine if SVG after mounting\n            isElementSVG: false\n          }, _this.onDragStart = function (e, coreEvent) {\n            (0, _log2.default)('Draggable: onDragStart: %j', coreEvent.position); // Short-circuit if user's callback killed it.\n\n            var shouldStart = _this.props.onStart(e, (0, _domFns.createUIEvent)(_this, coreEvent)); // Kills start event on core as well, so move handlers are never bound.\n\n\n            if (shouldStart === false) return false;\n\n            _this.setState({\n              dragging: true,\n              dragged: true\n            });\n          }, _this.onDrag = function (e, coreEvent) {\n            if (!_this.state.dragging) return false;\n            (0, _log2.default)('Draggable: onDrag: %j', coreEvent.position);\n            var uiEvent = (0, _domFns.createUIEvent)(_this, coreEvent);\n            var newState = {\n              clientX: uiEvent.position.left,\n              clientY: uiEvent.position.top\n            }; // Keep within bounds.\n\n            if (_this.props.bounds) {\n              // Save original x and y.\n              var _clientX = newState.clientX;\n              var _clientY = newState.clientY; // Add slack to the values used to calculate bound position. This will ensure that if\n              // we start removing slack, the element won't react to it right away until it's been\n              // completely removed.\n\n              newState.clientX += _this.state.slackX;\n              newState.clientY += _this.state.slackY; // Get bound position. This will ceil/floor the x and y within the boundaries.\n              // Recalculate slack by noting how much was shaved by the boundPosition handler.\n\n              var _getBoundPosition = (0, _positionFns.getBoundPosition)(_this, newState.clientX, newState.clientY);\n\n              var _getBoundPosition2 = _slicedToArray(_getBoundPosition, 2);\n\n              newState.clientX = _getBoundPosition2[0];\n              newState.clientY = _getBoundPosition2[1];\n              newState.slackX = _this.state.slackX + (_clientX - newState.clientX);\n              newState.slackY = _this.state.slackY + (_clientY - newState.clientY); // Update the event we fire to reflect what really happened after bounds took effect.\n\n              uiEvent.position.left = _clientX;\n              uiEvent.position.top = _clientY;\n              uiEvent.deltaX = newState.clientX - _this.state.clientX;\n              uiEvent.deltaY = newState.clientY - _this.state.clientY;\n            } // Short-circuit if user's callback killed it.\n\n\n            var shouldUpdate = _this.props.onDrag(e, uiEvent);\n\n            if (shouldUpdate === false) return false;\n\n            _this.setState(newState);\n          }, _this.onDragStop = function (e, coreEvent) {\n            if (!_this.state.dragging) return false; // Short-circuit if user's callback killed it.\n\n            var shouldStop = _this.props.onStop(e, (0, _domFns.createUIEvent)(_this, coreEvent));\n\n            if (shouldStop === false) return false;\n            (0, _log2.default)('Draggable: onDragStop: %j', coreEvent.position);\n\n            _this.setState({\n              dragging: false,\n              slackX: 0,\n              slackY: 0\n            });\n          }, _temp), _possibleConstructorReturn(_this, _ret);\n        }\n\n        _createClass(Draggable, [{\n          key: 'componentDidMount',\n          value: function componentDidMount() {\n            // Check to see if the element passed is an instanceof SVGElement\n            if (_reactDom2.default.findDOMNode(this) instanceof SVGElement) {\n              this.setState({\n                isElementSVG: true\n              });\n            }\n          }\n        }, {\n          key: 'componentWillUnmount',\n          value: function componentWillUnmount() {\n            this.setState({\n              dragging: false\n            }); // prevents invariant if unmounted while dragging\n          }\n        }, {\n          key: 'render',\n          value: function render() {\n            var style = {},\n                svgTransform = null; // Add a CSS transform to move the element around. This allows us to move the element around\n            // without worrying about whether or not it is relatively or absolutely positioned.\n            // If the item you are dragging already has a transform set, wrap it in a <span> so <Draggable>\n            // has a clean slate.\n\n            var transformOpts = {\n              // Set left if horizontal drag is enabled\n              x: (0, _positionFns.canDragX)(this) ? this.state.clientX : this.props.start.x,\n              // Set top if vertical drag is enabled\n              y: (0, _positionFns.canDragY)(this) ? this.state.clientY : this.props.start.y\n            }; // If this element was SVG, we use the `transform` attribute.\n\n            if (this.state.isElementSVG) {\n              svgTransform = (0, _domFns.createSVGTransform)(transformOpts);\n            } else {\n              style = (0, _domFns.createCSSTransform)(transformOpts);\n            } // zIndex option\n\n\n            if (this.state.dragging && !isNaN(this.props.zIndex)) {\n              style.zIndex = this.props.zIndex;\n            } // Mark with class while dragging\n\n\n            var className = (0, _classnames2.default)(this.props.children.props.className || '', 'react-draggable', {\n              'react-draggable-dragging': this.state.dragging,\n              'react-draggable-dragged': this.state.dragged\n            }); // Reuse the child provided\n            // This makes it flexible to use whatever element is wanted (div, ul, etc)\n\n            return _react2.default.createElement(_DraggableCore2.default, _extends({}, this.props, {\n              onStart: this.onDragStart,\n              onDrag: this.onDrag,\n              onStop: this.onDragStop\n            }), _react2.default.cloneElement(_react2.default.Children.only(this.props.children), {\n              className: className,\n              style: _extends({}, this.props.children.props.style, style),\n              transform: svgTransform\n            }));\n          }\n        }]);\n\n        return Draggable;\n      }(_react2.default.Component);\n\n      Draggable.displayName = 'Draggable';\n      Draggable.propTypes = _extends({}, _DraggableCore2.default.propTypes, {\n        /**\n         * `axis` determines which axis the draggable can move.\n         *\n         *  Note that all callbacks will still return data as normal. This only\n         *  controls flushing to the DOM.\n         *\n         * 'both' allows movement horizontally and vertically.\n         * 'x' limits movement to horizontal axis.\n         * 'y' limits movement to vertical axis.\n         * 'none' limits all movement.\n         *\n         * Defaults to 'both'.\n         */\n        axis: _react.PropTypes.oneOf(['both', 'x', 'y', 'none']),\n\n        /**\n         * `bounds` determines the range of movement available to the element.\n         * Available values are:\n         *\n         * 'parent' restricts movement within the Draggable's parent node.\n         *\n         * Alternatively, pass an object with the following properties, all of which are optional:\n         *\n         * {left: LEFT_BOUND, right: RIGHT_BOUND, bottom: BOTTOM_BOUND, top: TOP_BOUND}\n         *\n         * All values are in px.\n         *\n         * Example:\n         *\n         * ```jsx\n         *   let App = React.createClass({\n         *       render: function () {\n         *         return (\n         *            <Draggable bounds={{right: 300, bottom: 300}}>\n         *              <div>Content</div>\n         *           </Draggable>\n         *         );\n         *       }\n         *   });\n         * ```\n         */\n        bounds: _react.PropTypes.oneOfType([_react.PropTypes.shape({\n          left: _react.PropTypes.Number,\n          right: _react.PropTypes.Number,\n          top: _react.PropTypes.Number,\n          bottom: _react.PropTypes.Number\n        }), _react.PropTypes.string, _react.PropTypes.oneOf([false])]),\n\n        /**\n         * `start` specifies the x and y that the dragged item should start at\n         *\n         * Example:\n         *\n         * ```jsx\n         *      let App = React.createClass({\n         *          render: function () {\n         *              return (\n         *                  <Draggable start={{x: 25, y: 25}}>\n         *                      <div>I start with transformX: 25px and transformY: 25px;</div>\n         *                  </Draggable>\n         *              );\n         *          }\n         *      });\n         * ```\n         */\n        start: _react.PropTypes.shape({\n          x: _react.PropTypes.number,\n          y: _react.PropTypes.number\n        }),\n\n        /**\n         * `zIndex` specifies the zIndex to use while dragging.\n         *\n         * Example:\n         *\n         * ```jsx\n         *   let App = React.createClass({\n         *       render: function () {\n         *           return (\n         *               <Draggable zIndex={100}>\n         *                   <div>I have a zIndex</div>\n         *               </Draggable>\n         *           );\n         *       }\n         *   });\n         * ```\n         */\n        zIndex: _react.PropTypes.number,\n\n        /**\n         * These properties should be defined on the child, not here.\n         */\n        className: _shims.dontSetMe,\n        style: _shims.dontSetMe,\n        transform: _shims.dontSetMe\n      });\n      Draggable.defaultProps = _extends({}, _DraggableCore2.default.defaultProps, {\n        axis: 'both',\n        bounds: false,\n        start: {\n          x: 0,\n          y: 0\n        },\n        zIndex: NaN\n      });\n      exports.default = Draggable;\n      /***/\n    },\n    /* 2 */\n\n    /***/\n    function (module, exports) {\n      module.exports = __WEBPACK_EXTERNAL_MODULE_2__;\n      /***/\n    },\n    /* 3 */\n\n    /***/\n    function (module, exports) {\n      module.exports = __WEBPACK_EXTERNAL_MODULE_3__;\n      /***/\n    },\n    /* 4 */\n\n    /***/\n    function (module, exports, __webpack_require__) {\n      var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;\n      /*!\n      Copyright (c) 2016 Jed Watson.\n      Licensed under the MIT License (MIT), see\n      http://jedwatson.github.io/classnames\n      */\n\n      /* global define */\n\n\n      (function () {\n        'use strict';\n\n        var hasOwn = {}.hasOwnProperty;\n\n        function classNames() {\n          var classes = [];\n\n          for (var i = 0; i < arguments.length; i++) {\n            var arg = arguments[i];\n            if (!arg) continue;\n            var argType = typeof arg;\n\n            if (argType === 'string' || argType === 'number') {\n              classes.push(arg);\n            } else if (Array.isArray(arg)) {\n              classes.push(classNames.apply(null, arg));\n            } else if (argType === 'object') {\n              for (var key in arg) {\n                if (hasOwn.call(arg, key) && arg[key]) {\n                  classes.push(key);\n                }\n              }\n            }\n          }\n\n          return classes.join(' ');\n        }\n\n        if (typeof module !== 'undefined' && module.exports) {\n          module.exports = classNames;\n        } else if (true) {\n          // register as 'classnames', consistent with npm package name\n          !(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_RESULT__ = function () {\n            return classNames;\n          }.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n        } else {\n          window.classNames = classNames;\n        }\n      })();\n      /***/\n\n    },\n    /* 5 */\n\n    /***/\n    function (module, exports, __webpack_require__) {\n      'use strict';\n\n      Object.defineProperty(exports, \"__esModule\", {\n        value: true\n      });\n\n      var _extends = Object.assign || function (target) {\n        for (var i = 1; i < arguments.length; i++) {\n          var source = arguments[i];\n\n          for (var key in source) {\n            if (Object.prototype.hasOwnProperty.call(source, key)) {\n              target[key] = source[key];\n            }\n          }\n        }\n\n        return target;\n      };\n\n      exports.matchesSelector = matchesSelector;\n      exports.addEvent = addEvent;\n      exports.removeEvent = removeEvent;\n      exports.outerHeight = outerHeight;\n      exports.outerWidth = outerWidth;\n      exports.innerHeight = innerHeight;\n      exports.innerWidth = innerWidth;\n      exports.createCSSTransform = createCSSTransform;\n      exports.createSVGTransform = createSVGTransform;\n      exports.addUserSelectStyles = addUserSelectStyles;\n      exports.removeUserSelectStyles = removeUserSelectStyles;\n      exports.styleHacks = styleHacks;\n      exports.createCoreEvent = createCoreEvent;\n      exports.createUIEvent = createUIEvent;\n\n      var _shims = __webpack_require__(6);\n\n      var _getPrefix = __webpack_require__(7);\n\n      var _getPrefix2 = _interopRequireDefault(_getPrefix);\n\n      var _reactDom = __webpack_require__(3);\n\n      var _reactDom2 = _interopRequireDefault(_reactDom);\n\n      function _interopRequireDefault(obj) {\n        return obj && obj.__esModule ? obj : {\n          default: obj\n        };\n      }\n\n      function _defineProperty(obj, key, value) {\n        if (key in obj) {\n          Object.defineProperty(obj, key, {\n            value: value,\n            enumerable: true,\n            configurable: true,\n            writable: true\n          });\n        } else {\n          obj[key] = value;\n        }\n\n        return obj;\n      }\n\n      var matchesSelectorFunc = '';\n\n      function matchesSelector(el, selector) {\n        if (!matchesSelectorFunc) {\n          matchesSelectorFunc = (0, _shims.findInArray)(['matches', 'webkitMatchesSelector', 'mozMatchesSelector', 'msMatchesSelector', 'oMatchesSelector'], function (method) {\n            // $FlowIgnore: Doesn't think elements are indexable\n            return (0, _shims.isFunction)(el[method]);\n          });\n        } // $FlowIgnore: Doesn't think elements are indexable\n\n\n        return el[matchesSelectorFunc].call(el, selector);\n      }\n\n      function addEvent(el, event, handler) {\n        if (!el) {\n          return;\n        }\n\n        if (el.attachEvent) {\n          el.attachEvent('on' + event, handler);\n        } else if (el.addEventListener) {\n          el.addEventListener(event, handler, true);\n        } else {\n          // $FlowIgnore: Doesn't think elements are indexable\n          el['on' + event] = handler;\n        }\n      }\n\n      function removeEvent(el, event, handler) {\n        if (!el) {\n          return;\n        }\n\n        if (el.detachEvent) {\n          el.detachEvent('on' + event, handler);\n        } else if (el.removeEventListener) {\n          el.removeEventListener(event, handler, true);\n        } else {\n          // $FlowIgnore: Doesn't think elements are indexable\n          el['on' + event] = null;\n        }\n      }\n\n      function outerHeight(node) {\n        // This is deliberately excluding margin for our calculations, since we are using\n        // offsetTop which is including margin. See getBoundPosition\n        var height = node.clientHeight;\n        var computedStyle = window.getComputedStyle(node);\n        height += (0, _shims.int)(computedStyle.borderTopWidth);\n        height += (0, _shims.int)(computedStyle.borderBottomWidth);\n        return height;\n      }\n\n      function outerWidth(node) {\n        // This is deliberately excluding margin for our calculations, since we are using\n        // offsetLeft which is including margin. See getBoundPosition\n        var width = node.clientWidth;\n        var computedStyle = window.getComputedStyle(node);\n        width += (0, _shims.int)(computedStyle.borderLeftWidth);\n        width += (0, _shims.int)(computedStyle.borderRightWidth);\n        return width;\n      }\n\n      function innerHeight(node) {\n        var height = node.clientHeight;\n        var computedStyle = window.getComputedStyle(node);\n        height -= (0, _shims.int)(computedStyle.paddingTop);\n        height -= (0, _shims.int)(computedStyle.paddingBottom);\n        return height;\n      }\n\n      function innerWidth(node) {\n        var width = node.clientWidth;\n        var computedStyle = window.getComputedStyle(node);\n        width -= (0, _shims.int)(computedStyle.paddingLeft);\n        width -= (0, _shims.int)(computedStyle.paddingRight);\n        return width;\n      }\n\n      function createCSSTransform(_ref) {\n        var x = _ref.x;\n        var y = _ref.y; // Replace unitless items with px\n\n        return _defineProperty({}, (0, _getPrefix.browserPrefixToKey)('transform', _getPrefix2.default), 'translate(' + x + 'px,' + y + 'px)');\n      }\n\n      function createSVGTransform(_ref3) {\n        var x = _ref3.x;\n        var y = _ref3.y;\n        return 'translate(' + x + ',' + y + ')';\n      } // User-select Hacks:\n      //\n      // Useful for preventing blue highlights all over everything when dragging.\n\n\n      var userSelectPrefix = (0, _getPrefix.getPrefix)('user-select');\n      var userSelect = (0, _getPrefix.browserPrefixToStyle)('user-select', userSelectPrefix);\n      var userSelectStyle = ';' + userSelect + ': none;';\n\n      function addUserSelectStyles() {\n        var style = document.body.getAttribute('style') || '';\n        document.body.setAttribute('style', style + userSelectStyle);\n      }\n\n      function removeUserSelectStyles() {\n        var style = document.body.getAttribute('style') || '';\n        document.body.setAttribute('style', style.replace(userSelectStyle, ''));\n      }\n\n      function styleHacks() {\n        var childStyle = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0]; // Workaround IE pointer events; see #51\n        // https://github.com/mzabriskie/react-draggable/issues/51#issuecomment-103488278\n\n        return _extends({\n          touchAction: 'none'\n        }, childStyle);\n      } // Create an event exposed by <DraggableCore>\n\n\n      function createCoreEvent(draggable, clientX, clientY) {\n        // State changes are often (but not always!) async. We want the latest value.\n        var state = draggable._pendingState || draggable.state;\n        var isStart = !(0, _shims.isNum)(state.lastX);\n        return {\n          node: _reactDom2.default.findDOMNode(draggable),\n          position: isStart ? // If this is our first move, use the clientX and clientY as last coords.\n          {\n            deltaX: 0,\n            deltaY: 0,\n            lastX: clientX,\n            lastY: clientY,\n            clientX: clientX,\n            clientY: clientY\n          } : // Otherwise calculate proper values.\n          {\n            deltaX: clientX - state.lastX,\n            deltaY: clientY - state.lastY,\n            lastX: state.lastX,\n            lastY: state.lastY,\n            clientX: clientX,\n            clientY: clientY\n          }\n        };\n      } // Create an event exposed by <Draggable>\n\n\n      function createUIEvent(draggable, coreEvent) {\n        return {\n          node: _reactDom2.default.findDOMNode(draggable),\n          position: {\n            left: draggable.state.clientX + coreEvent.position.deltaX,\n            top: draggable.state.clientY + coreEvent.position.deltaY\n          },\n          deltaX: coreEvent.position.deltaX,\n          deltaY: coreEvent.position.deltaY\n        };\n      }\n      /***/\n\n    },\n    /* 6 */\n\n    /***/\n    function (module, exports) {\n      'use strict';\n\n      Object.defineProperty(exports, \"__esModule\", {\n        value: true\n      });\n      exports.findInArray = findInArray;\n      exports.isFunction = isFunction;\n      exports.isNum = isNum;\n      exports.int = int;\n      exports.dontSetMe = dontSetMe; // @credits https://gist.github.com/rogozhnikoff/a43cfed27c41e4e68cdc\n\n      function findInArray(array, callback) {\n        for (var i = 0, length = array.length; i < length; i++) {\n          if (callback.apply(callback, [array[i], i, array])) return array[i];\n        }\n      }\n\n      function isFunction(func) {\n        return typeof func === 'function' || Object.prototype.toString.call(func) === '[object Function]';\n      }\n\n      function isNum(num) {\n        return typeof num === 'number' && !isNaN(num);\n      }\n\n      function int(a) {\n        return parseInt(a, 10);\n      }\n\n      function dontSetMe(props, propName, componentName) {\n        if (props[propName]) {\n          throw new Error('Invalid prop ' + propName + ' passed to ' + componentName + ' - do not set this, set it on the child.');\n        }\n      }\n      /***/\n\n    },\n    /* 7 */\n\n    /***/\n    function (module, exports) {\n      'use strict';\n\n      Object.defineProperty(exports, \"__esModule\", {\n        value: true\n      });\n      exports.getPrefix = getPrefix;\n      exports.browserPrefixToKey = browserPrefixToKey;\n      exports.browserPrefixToStyle = browserPrefixToStyle;\n      var prefixes = ['Moz', 'Webkit', 'O', 'ms'];\n\n      function getPrefix() {\n        var prop = arguments.length <= 0 || arguments[0] === undefined ? 'transform' : arguments[0]; // Checking specifically for 'window.document' is for pseudo-browser server-side\n        // environments that define 'window' as the global context.\n        // E.g. React-rails (see https://github.com/reactjs/react-rails/pull/84)\n\n        if (typeof window === 'undefined' || typeof window.document === 'undefined') return '';\n        var style = window.document.documentElement.style;\n        if (prop in style) return '';\n\n        for (var i = 0; i < prefixes.length; i++) {\n          if (browserPrefixToStyle(prop, prefixes[i]) in style) return prefixes[i];\n        }\n\n        return '';\n      }\n\n      function browserPrefixToKey(prop, prefix) {\n        return prefix ? '' + prefix + kebabToTitleCase(prop) : prop;\n      }\n\n      function browserPrefixToStyle(prop, prefix) {\n        return prefix ? '-' + prefix.toLowerCase() + '-' + prop : prop;\n      }\n\n      function kebabToTitleCase(str) {\n        var out = '';\n        var shouldCapitalize = true;\n\n        for (var i = 0; i < str.length; i++) {\n          if (shouldCapitalize) {\n            out += str[i].toUpperCase();\n            shouldCapitalize = false;\n          } else if (str[i] === '-') {\n            shouldCapitalize = true;\n          } else {\n            out += str[i];\n          }\n        }\n\n        return out;\n      } // Default export is the prefix itself, like 'Moz', 'Webkit', etc\n      // Note that you may have to re-test for certain things; for instance, Chrome 50\n      // can handle unprefixed `transform`, but not unprefixed `user-select`\n\n\n      exports.default = getPrefix();\n      /***/\n    },\n    /* 8 */\n\n    /***/\n    function (module, exports, __webpack_require__) {\n      'use strict';\n\n      Object.defineProperty(exports, \"__esModule\", {\n        value: true\n      });\n      exports.getBoundPosition = getBoundPosition;\n      exports.snapToGrid = snapToGrid;\n      exports.canDragX = canDragX;\n      exports.canDragY = canDragY;\n      exports.getControlPosition = getControlPosition;\n\n      var _react = __webpack_require__(2);\n\n      var _react2 = _interopRequireDefault(_react);\n\n      var _shims = __webpack_require__(6);\n\n      var _reactDom = __webpack_require__(3);\n\n      var _reactDom2 = _interopRequireDefault(_reactDom);\n\n      var _domFns = __webpack_require__(5);\n\n      function _interopRequireDefault(obj) {\n        return obj && obj.__esModule ? obj : {\n          default: obj\n        };\n      }\n\n      function getBoundPosition(draggable, clientX, clientY) {\n        // If no bounds, short-circuit and move on\n        if (!draggable.props.bounds) return [clientX, clientY]; // Clone new bounds\n\n        var bounds = draggable.props.bounds;\n        bounds = typeof bounds === 'string' ? bounds : cloneBounds(bounds);\n\n        var node = _reactDom2.default.findDOMNode(draggable);\n\n        if (typeof bounds === 'string') {\n          var boundNode = void 0;\n\n          if (bounds === 'parent') {\n            boundNode = node.parentNode;\n          } else {\n            boundNode = document.querySelector(bounds);\n            if (!boundNode) throw new Error('Bounds selector \"' + bounds + '\" could not find an element.');\n          }\n\n          var nodeStyle = window.getComputedStyle(node);\n          var boundNodeStyle = window.getComputedStyle(boundNode); // Compute bounds. This is a pain with padding and offsets but this gets it exactly right.\n\n          bounds = {\n            left: -node.offsetLeft + (0, _shims.int)(boundNodeStyle.paddingLeft) + (0, _shims.int)(nodeStyle.borderLeftWidth) + (0, _shims.int)(nodeStyle.marginLeft),\n            top: -node.offsetTop + (0, _shims.int)(boundNodeStyle.paddingTop) + (0, _shims.int)(nodeStyle.borderTopWidth) + (0, _shims.int)(nodeStyle.marginTop),\n            right: (0, _domFns.innerWidth)(boundNode) - (0, _domFns.outerWidth)(node) - node.offsetLeft,\n            bottom: (0, _domFns.innerHeight)(boundNode) - (0, _domFns.outerHeight)(node) - node.offsetTop\n          };\n        } // Keep x and y below right and bottom limits...\n\n\n        if ((0, _shims.isNum)(bounds.right)) clientX = Math.min(clientX, bounds.right);\n        if ((0, _shims.isNum)(bounds.bottom)) clientY = Math.min(clientY, bounds.bottom); // But above left and top limits.\n\n        if ((0, _shims.isNum)(bounds.left)) clientX = Math.max(clientX, bounds.left);\n        if ((0, _shims.isNum)(bounds.top)) clientY = Math.max(clientY, bounds.top);\n        return [clientX, clientY];\n      }\n\n      function snapToGrid(grid, pendingX, pendingY) {\n        var x = Math.round(pendingX / grid[0]) * grid[0];\n        var y = Math.round(pendingY / grid[1]) * grid[1];\n        return [x, y];\n      }\n\n      function canDragX(draggable) {\n        return draggable.props.axis === 'both' || draggable.props.axis === 'x';\n      }\n\n      function canDragY(draggable) {\n        return draggable.props.axis === 'both' || draggable.props.axis === 'y';\n      } // Get {clientX, clientY} positions from event.\n\n\n      function getControlPosition(e) {\n        var position = e.targetTouches && e.targetTouches[0] || e;\n        return {\n          clientX: position.clientX,\n          clientY: position.clientY\n        };\n      } // A lot faster than stringify/parse\n\n\n      function cloneBounds(bounds) {\n        return {\n          left: bounds.left,\n          top: bounds.top,\n          right: bounds.right,\n          bottom: bounds.bottom\n        };\n      }\n      /***/\n\n    },\n    /* 9 */\n\n    /***/\n    function (module, exports, __webpack_require__) {\n      'use strict';\n\n      Object.defineProperty(exports, \"__esModule\", {\n        value: true\n      });\n\n      var _slicedToArray = function () {\n        function sliceIterator(arr, i) {\n          var _arr = [];\n          var _n = true;\n          var _d = false;\n          var _e = undefined;\n\n          try {\n            for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {\n              _arr.push(_s.value);\n\n              if (i && _arr.length === i) break;\n            }\n          } catch (err) {\n            _d = true;\n            _e = err;\n          } finally {\n            try {\n              if (!_n && _i[\"return\"]) _i[\"return\"]();\n            } finally {\n              if (_d) throw _e;\n            }\n          }\n\n          return _arr;\n        }\n\n        return function (arr, i) {\n          if (Array.isArray(arr)) {\n            return arr;\n          } else if (Symbol.iterator in Object(arr)) {\n            return sliceIterator(arr, i);\n          } else {\n            throw new TypeError(\"Invalid attempt to destructure non-iterable instance\");\n          }\n        };\n      }();\n\n      var _createClass = function () {\n        function defineProperties(target, props) {\n          for (var i = 0; i < props.length; i++) {\n            var descriptor = props[i];\n            descriptor.enumerable = descriptor.enumerable || false;\n            descriptor.configurable = true;\n            if (\"value\" in descriptor) descriptor.writable = true;\n            Object.defineProperty(target, descriptor.key, descriptor);\n          }\n        }\n\n        return function (Constructor, protoProps, staticProps) {\n          if (protoProps) defineProperties(Constructor.prototype, protoProps);\n          if (staticProps) defineProperties(Constructor, staticProps);\n          return Constructor;\n        };\n      }();\n\n      var _react = __webpack_require__(2);\n\n      var _react2 = _interopRequireDefault(_react);\n\n      var _domFns = __webpack_require__(5);\n\n      var _positionFns = __webpack_require__(8);\n\n      var _shims = __webpack_require__(6);\n\n      var _log = __webpack_require__(10);\n\n      var _log2 = _interopRequireDefault(_log);\n\n      function _interopRequireDefault(obj) {\n        return obj && obj.__esModule ? obj : {\n          default: obj\n        };\n      }\n\n      function _classCallCheck(instance, Constructor) {\n        if (!(instance instanceof Constructor)) {\n          throw new TypeError(\"Cannot call a class as a function\");\n        }\n      }\n\n      function _possibleConstructorReturn(self, call) {\n        if (!self) {\n          throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n        }\n\n        return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self;\n      }\n\n      function _inherits(subClass, superClass) {\n        if (typeof superClass !== \"function\" && superClass !== null) {\n          throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass);\n        }\n\n        subClass.prototype = Object.create(superClass && superClass.prototype, {\n          constructor: {\n            value: subClass,\n            enumerable: false,\n            writable: true,\n            configurable: true\n          }\n        });\n        if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;\n      } // Simple abstraction for dragging events names.\n\n\n      var eventsFor = {\n        touch: {\n          start: 'touchstart',\n          move: 'touchmove',\n          stop: 'touchend'\n        },\n        mouse: {\n          start: 'mousedown',\n          move: 'mousemove',\n          stop: 'mouseup'\n        }\n      }; // Default to mouse events.\n\n      var dragEventFor = eventsFor.mouse; //\n      // Define <DraggableCore>.\n      //\n      // <DraggableCore> is for advanced usage of <Draggable>. It maintains minimal internal state so it can\n      // work well with libraries that require more control over the element.\n      //\n\n      var DraggableCore = function (_React$Component) {\n        _inherits(DraggableCore, _React$Component);\n\n        function DraggableCore() {\n          var _Object$getPrototypeO;\n\n          var _temp, _this, _ret;\n\n          _classCallCheck(this, DraggableCore);\n\n          for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {\n            args[_key] = arguments[_key];\n          }\n\n          return _ret = (_temp = (_this = _possibleConstructorReturn(this, (_Object$getPrototypeO = Object.getPrototypeOf(DraggableCore)).call.apply(_Object$getPrototypeO, [this].concat(args))), _this), _this.state = {\n            dragging: false,\n            // Used while dragging to determine deltas.\n            lastX: null,\n            lastY: null\n          }, _this.handleDragStart = function (e) {\n            // Make it possible to attach event handlers on top of this one.\n            _this.props.onMouseDown(e); // Only accept left-clicks.\n\n\n            if (!_this.props.allowAnyClick && typeof e.button === 'number' && e.button !== 0) return false; // Short circuit if handle or cancel prop was provided and selector doesn't match.\n\n            if (_this.props.disabled || _this.props.handle && !(0, _domFns.matchesSelector)(e.target, _this.props.handle) || _this.props.cancel && (0, _domFns.matchesSelector)(e.target, _this.props.cancel)) {\n              return;\n            } // Set touch identifier in component state if this is a touch event. This allows us to\n            // distinguish between individual touches on multitouch screens by identifying which\n            // touchpoint was set to this element.\n\n\n            if (e.targetTouches) {\n              _this.setState({\n                touchIdentifier: e.targetTouches[0].identifier\n              });\n            } // Add a style to the body to disable user-select. This prevents text from\n            // being selected all over the page.\n\n\n            if (_this.props.enableUserSelectHack) (0, _domFns.addUserSelectStyles)(); // Get the current drag point from the event. This is used as the offset.\n\n            var _getControlPosition = (0, _positionFns.getControlPosition)(e);\n\n            var clientX = _getControlPosition.clientX;\n            var clientY = _getControlPosition.clientY; // Create an event object with all the data parents need to make a decision here.\n\n            var coreEvent = (0, _domFns.createCoreEvent)(_this, clientX, clientY);\n            (0, _log2.default)('DraggableCore: handleDragStart: %j', coreEvent.position); // Call event handler. If it returns explicit false, cancel.\n\n            (0, _log2.default)('calling', _this.props.onStart);\n\n            var shouldUpdate = _this.props.onStart(e, coreEvent);\n\n            if (shouldUpdate === false) return; // Initiate dragging. Set the current x and y as offsets\n            // so we know how much we've moved during the drag. This allows us\n            // to drag elements around even if they have been moved, without issue.\n\n            _this.setState({\n              dragging: true,\n              lastX: clientX,\n              lastY: clientY,\n              // Stored so we can adjust our offset if scrolled.\n              scrollX: document.body.scrollLeft,\n              scrollY: document.body.scrollTop\n            }); // Translate el on page scroll.\n\n\n            (0, _domFns.addEvent)(document, 'scroll', _this.handleScroll); // Add events to the document directly so we catch when the user's mouse/touch moves outside of\n            // this element. We use different events depending on whether or not we have detected that this\n            // is a touch-capable device.\n\n            (0, _domFns.addEvent)(document, dragEventFor.move, _this.handleDrag);\n            (0, _domFns.addEvent)(document, dragEventFor.stop, _this.handleDragStop);\n          }, _this.handleDrag = function (e) {\n            // Return if this is a touch event, but not the correct one for this element\n            if (e.targetTouches && e.targetTouches[0].identifier !== _this.state.touchIdentifier) return;\n\n            var _getControlPosition2 = (0, _positionFns.getControlPosition)(e);\n\n            var clientX = _getControlPosition2.clientX;\n            var clientY = _getControlPosition2.clientY; // Snap to grid if prop has been provided\n\n            if (Array.isArray(_this.props.grid)) {\n              var deltaX = clientX - _this.state.lastX,\n                  deltaY = clientY - _this.state.lastY;\n\n              var _snapToGrid = (0, _positionFns.snapToGrid)(_this.props.grid, deltaX, deltaY);\n\n              var _snapToGrid2 = _slicedToArray(_snapToGrid, 2);\n\n              deltaX = _snapToGrid2[0];\n              deltaY = _snapToGrid2[1];\n              if (!deltaX && !deltaY) return; // skip useless drag\n\n              clientX = _this.state.lastX + deltaX, clientY = _this.state.lastY + deltaY;\n            }\n\n            var coreEvent = (0, _domFns.createCoreEvent)(_this, clientX, clientY);\n            (0, _log2.default)('DraggableCore: handleDrag: %j', coreEvent.position); // Call event handler. If it returns explicit false, trigger end.\n\n            var shouldUpdate = _this.props.onDrag(e, coreEvent);\n\n            if (shouldUpdate === false) {\n              _this.handleDragStop({});\n\n              return;\n            }\n\n            _this.setState({\n              lastX: clientX,\n              lastY: clientY\n            });\n          }, _this.handleDragStop = function (e) {\n            if (!_this.state.dragging) return; // Short circuit if this is not the correct touch event. `changedTouches` contains all\n            // touch points that have been removed from the surface.\n\n            if (e.changedTouches && e.changedTouches[0].identifier !== _this.state.touchIdentifier) return; // Remove user-select hack\n\n            if (_this.props.enableUserSelectHack) (0, _domFns.removeUserSelectStyles)();\n\n            var _getControlPosition3 = (0, _positionFns.getControlPosition)(e);\n\n            var clientX = _getControlPosition3.clientX;\n            var clientY = _getControlPosition3.clientY;\n            var coreEvent = (0, _domFns.createCoreEvent)(_this, clientX, clientY);\n            (0, _log2.default)('DraggableCore: handleDragStop: %j', coreEvent.position); // Reset the el.\n\n            _this.setState({\n              dragging: false,\n              lastX: null,\n              lastY: null\n            }); // Call event handler\n\n\n            _this.props.onStop(e, coreEvent); // Remove event handlers\n\n\n            (0, _log2.default)('DraggableCore: Removing handlers');\n            (0, _domFns.removeEvent)(document, 'scroll', _this.handleScroll);\n            (0, _domFns.removeEvent)(document, dragEventFor.move, _this.handleDrag);\n            (0, _domFns.removeEvent)(document, dragEventFor.stop, _this.handleDragStop);\n          }, _this.handleScroll = function (e) {\n            var s = _this.state,\n                x = document.body.scrollLeft,\n                y = document.body.scrollTop; // Create the usual event, but make the scroll offset our deltas.\n\n            var coreEvent = (0, _domFns.createCoreEvent)(_this);\n            coreEvent.position.deltaX = x - s.scrollX;\n            coreEvent.position.deltaY = y - s.scrollY;\n\n            _this.setState({\n              lastX: s.lastX + coreEvent.position.deltaX,\n              lastY: s.lastY + coreEvent.position.deltaY,\n              scrollX: x,\n              scrollY: y\n            });\n\n            _this.props.onDrag(e, coreEvent);\n          }, _this.onMouseDown = function (e) {\n            dragEventFor = eventsFor.mouse; // on touchscreen laptops we could switch back to mouse\n\n            return _this.handleDragStart(e);\n          }, _this.onMouseUp = function (e) {\n            dragEventFor = eventsFor.mouse;\n            return _this.handleDragStop(e);\n          }, _this.onTouchStart = function (e) {\n            // We're on a touch device now, so change the event handlers\n            dragEventFor = eventsFor.touch;\n            return _this.handleDragStart(e);\n          }, _this.onTouchEnd = function (e) {\n            // We're on a touch device now, so change the event handlers\n            dragEventFor = eventsFor.touch;\n            return _this.handleDragStop(e);\n          }, _temp), _possibleConstructorReturn(_this, _ret);\n        }\n\n        _createClass(DraggableCore, [{\n          key: 'componentWillUnmount',\n          value: function componentWillUnmount() {\n            // Remove any leftover event handlers. Remove both touch and mouse handlers in case\n            // some browser quirk caused a touch event to fire during a mouse move, or vice versa.\n            (0, _domFns.removeEvent)(document, eventsFor.mouse.move, this.handleDrag);\n            (0, _domFns.removeEvent)(document, eventsFor.touch.move, this.handleDrag);\n            (0, _domFns.removeEvent)(document, eventsFor.mouse.stop, this.handleDragStop);\n            (0, _domFns.removeEvent)(document, eventsFor.touch.stop, this.handleDragStop);\n            (0, _domFns.removeEvent)(document, 'scroll', this.handleScroll);\n            if (this.props.enableUserSelectHack) (0, _domFns.removeUserSelectStyles)();\n          } // When the user scrolls, adjust internal state so the draggable moves along the page properly.\n          // This only fires when a drag is active.\n          // Same as onMouseDown (start drag), but now consider this a touch device.\n\n        }, {\n          key: 'render',\n          value: function render() {\n            // Reuse the child provided\n            // This makes it flexible to use whatever element is wanted (div, ul, etc)\n            return _react2.default.cloneElement(_react2.default.Children.only(this.props.children), {\n              style: (0, _domFns.styleHacks)(this.props.children.props.style),\n              // Note: mouseMove handler is attached to document so it will still function\n              // when the user drags quickly and leaves the bounds of the element.\n              onMouseDown: this.onMouseDown,\n              onTouchStart: this.onTouchStart,\n              onMouseUp: this.onMouseUp,\n              onTouchEnd: this.onTouchEnd\n            });\n          }\n        }]);\n\n        return DraggableCore;\n      }(_react2.default.Component);\n\n      DraggableCore.displayName = 'DraggableCore';\n      DraggableCore.propTypes = {\n        /**\n         * `allowAnyClick` allows dragging using any mouse button.\n         * By default, we only accept the left button.\n         *\n         * Defaults to `false`.\n         */\n        allowAnyClick: _react.PropTypes.bool,\n\n        /**\n         * `disabled`, if true, stops the <Draggable> from dragging. All handlers,\n         * with the exception of `onMouseDown`, will not fire.\n         *\n         * Example:\n         *\n         * ```jsx\n         *   let App = React.createClass({\n         *       render: function () {\n         *           return (\n         *               <Draggable disabled={true}>\n         *                   <div>I can't be dragged</div>\n         *               </Draggable>\n         *           );\n         *       }\n         *   });\n         * ```\n         */\n        disabled: _react.PropTypes.bool,\n\n        /**\n         * By default, we add 'user-select:none' attributes to the document body\n         * to prevent ugly text selection during drag. If this is causing problems\n         * for your app, set this to `false`.\n         */\n        enableUserSelectHack: _react.PropTypes.bool,\n\n        /**\n         * `grid` specifies the x and y that dragging should snap to.\n         *\n         * Example:\n         *\n         * ```jsx\n         *   let App = React.createClass({\n         *       render: function () {\n         *           return (\n         *               <Draggable grid={[25, 25]}>\n         *                   <div>I snap to a 25 x 25 grid</div>\n         *               </Draggable>\n         *           );\n         *       }\n         *   });\n         * ```\n         */\n        grid: _react.PropTypes.arrayOf(_react.PropTypes.number),\n\n        /**\n         * `handle` specifies a selector to be used as the handle that initiates drag.\n         *\n         * Example:\n         *\n         * ```jsx\n         *   let App = React.createClass({\n         *       render: function () {\n         *         return (\n         *            <Draggable handle=\".handle\">\n         *              <div>\n         *                  <div className=\"handle\">Click me to drag</div>\n         *                  <div>This is some other content</div>\n         *              </div>\n         *           </Draggable>\n         *         );\n         *       }\n         *   });\n         * ```\n         */\n        handle: _react.PropTypes.string,\n\n        /**\n         * `cancel` specifies a selector to be used to prevent drag initialization.\n         *\n         * Example:\n         *\n         * ```jsx\n         *   let App = React.createClass({\n         *       render: function () {\n         *           return(\n         *               <Draggable cancel=\".cancel\">\n         *                   <div>\n         *                     <div className=\"cancel\">You can't drag from here</div>\n         *            <div>Dragging here works fine</div>\n         *                   </div>\n         *               </Draggable>\n         *           );\n         *       }\n         *   });\n         * ```\n         */\n        cancel: _react.PropTypes.string,\n\n        /**\n         * Called when dragging starts.\n         * If this function returns the boolean false, dragging will be canceled.\n         *\n         * Example:\n         *\n         * ```js\n         *  function (event, ui) {}\n         * ```\n         *\n         * `event` is the Event that was triggered.\n         * `ui` is an object:\n         *\n         * ```js\n         *  {\n         *    position: {top: 0, left: 0}\n         *  }\n         * ```\n         */\n        onStart: _react.PropTypes.func,\n\n        /**\n         * Called while dragging.\n         * If this function returns the boolean false, dragging will be canceled.\n         *\n         * Example:\n         *\n         * ```js\n         *  function (event, ui) {}\n         * ```\n         *\n         * `event` is the Event that was triggered.\n         * `ui` is an object:\n         *\n         * ```js\n         *  {\n         *    position: {top: 0, left: 0}\n         *  }\n         * ```\n         */\n        onDrag: _react.PropTypes.func,\n\n        /**\n         * Called when dragging stops.\n         *\n         * Example:\n         *\n         * ```js\n         *  function (event, ui) {}\n         * ```\n         *\n         * `event` is the Event that was triggered.\n         * `ui` is an object:\n         *\n         * ```js\n         *  {\n         *    position: {top: 0, left: 0}\n         *  }\n         * ```\n         */\n        onStop: _react.PropTypes.func,\n\n        /**\n         * A workaround option which can be passed if onMouseDown needs to be accessed,\n         * since it'll always be blocked (due to that there's internal use of onMouseDown)\n         */\n        onMouseDown: _react.PropTypes.func,\n\n        /**\n         * These properties should be defined on the child, not here.\n         */\n        className: _shims.dontSetMe,\n        style: _shims.dontSetMe,\n        transform: _shims.dontSetMe\n      };\n      DraggableCore.defaultProps = {\n        allowAnyClick: false,\n        // by default only accept left click\n        cancel: null,\n        disabled: false,\n        enableUserSelectHack: true,\n        handle: null,\n        grid: null,\n        transform: null,\n        onStart: function onStart() {},\n        onDrag: function onDrag() {},\n        onStop: function onStop() {},\n        onMouseDown: function onMouseDown() {}\n      };\n      exports.default = DraggableCore;\n      /***/\n    },\n    /* 10 */\n\n    /***/\n    function (module, exports, __webpack_require__) {\n      \"use strict\";\n\n      Object.defineProperty(exports, \"__esModule\", {\n        value: true\n      });\n      exports.default = log;\n\n      function log() {\n        var _console;\n\n        if (undefined) (_console = console).log.apply(_console, arguments);\n      }\n      /***/\n\n    }\n    /******/\n    ])\n  );\n});\n\n;","map":null,"metadata":{},"sourceType":"script"}